## Описание задач финального спринта №2: "Основные структуры данных."
### Задача №1 "Дек":
Гоша реализовал структуру данных Дек, максимальный размер которого определяется заданным числом. 
Методы push_back(x), push_front(x), pop_back(), pop_front() работали корректно. Но, если в деке было много элементов, 
программа работала очень долго. Дело в том, что не все операции выполнялись за O(1). 
Помогите Гоше! Напишите эффективную реализацию.

_Внимание:_ при реализации используйте кольцевой буфер.

#### Формат ввода
В первой строке записано количество команд `n` — целое число, не превосходящее 100000. \
Во второй строке записано число `m` — максимальный размер дека. Он не превосходит 50000. 
В следующих `n` строках записана одна из команд:

`push_back(value)` – добавить элемент в конец дека. Если в деке уже находится максимальное число элементов, вывести «error».

`push_front(value)` – добавить элемент в начало дека. Если в деке уже находится максимальное число элементов, вывести «error».

`pop_front()` – вывести первый элемент дека и удалить его. Если дек был пуст, то вывести «error».

`pop_back()` – вывести последний элемент дека и удалить его. Если дек был пуст, то вывести «error».

`value` — целое число, по модулю не превосходящее 1000.

#### Формат вывода
Выведите результат выполнения каждой команды на отдельной строке. Для успешных запросов push_back(x) и push_front(x) ничего выводить не надо.


#### Описание алгоритма

При реализации решения задачи использовался стандартный список(`list`) `Python`. Использовался кольцевой буфер.

Временная сложность доступа к элементам `list` имеет сложность `O(1)`, поэтому реализованные функции имеют сложность `O(1)`.
В алгоритме не используется дополнительная память, поэтому затраты по памяти так же составляют `O(1)`.


За основу взял описание структуры "Дек" описанную в курсе.

Посылка указанна в комментариях к коду.
