"""
Алгоритм Эратосфена.

1. Выписываем все целые числа от 0 до n.
Сразу помечаем, что числа 0 и 1 не являются простыми (записываем на соответствующих этим числам позициях False).

2. Заводим переменную num, равную первому не рассмотренному простому числу. Изначально она равна 2.

3. Помечаем в списке числа от 2⋅num до n с шагом, равным num, составными.
Например, для 2 пометим значением False чётные числа — 4, 6, 8 и так далее.

4. Теперь в num присваиваем следующее простое число, то есть следующее не рассмотренное число в списке.
Для этого достаточно увеличивать num с шагом 1, пропуская числа, отмеченные как составные.
На первом найденном простом числе следует остановиться.

5. Повторяем два предыдущих шага, пока это возможно.
"""


def eratosthenes(n: int) -> list:
    numbers = list(range(n + 1))
    numbers[0] = numbers[1] = False
    for num in range(2, n):
        if numbers[num]:
            for j in range(2 * num, n + 1, num):
                numbers[j] = False
    return numbers


def eratosthenes_effective(n: int) -> list[int]:
    """Алгоритм можно оптимизировать. Для каждого простого числа
    p начнём отмечать числа, начиная с p^2,
    как составные. Ведь все составные числа,
    которые меньше него, будут уже рассмотрены.
    """
    numbers = list(range(n + 1))
    numbers[0] = numbers[1] = False
    for num in range(2, n):
        if numbers[num]:
            for j in range(num * num, n + 1, num):
                numbers[j] = False
    return [num for num in numbers if num]
