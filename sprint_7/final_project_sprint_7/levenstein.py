"""
-- ПРИНЦИП РАБОТЫ --
В этой задаче вычисляется матрица расстояний по Левенштейну для двух строк - 's' и 't'.

Инициализируем масссив 'dp' размером len(s) x len(t), где
    dp[i][j] - минимальное количество операций, необходимых для преобразования
символов строки s в строку t.

Заполняем первую строку и первый столбец массива от нуля до длины строки,
что соответствует последовательным удалениям и вставкам символов.

Проходим по массиву и заполняем его:
 - если символы совпадают, тогда берем предыдущее значение из диагонали матрицы.
 - если нет, тогда берем минимальное значение из трех предыдущих значений:
 строки, столбца или диагонали и добавляем 1.
Таким образом происходит подсчет количества изменений одной строки в другую.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Так как у нас на входе принимается 2 массива строк величиной 'M'и 'N', то
временная сложность составляет O(N*M).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
При вычислениях мы храним матрицу размером M*N, поэтому временная сложность
равна O(N*M).

Посылка: https://contest.yandex.ru/contest/25597/run-report/115012899/
"""


def levenshtein_distance(s: str, t: str) -> int:
    m, n = len(s), len(t)
    dp: list[list[int]] = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])

    return dp[m][n]


s: str = input().strip()
t: str = input().strip()
print(levenshtein_distance(s, t))
