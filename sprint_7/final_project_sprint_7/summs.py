"""
-- ПРИНЦИП РАБОТЫ --
В этой задаче нужно проверить, можно ли разделить список очков на 2 части
с одинаковой суммой.

Вычисляем сумму всех очков.

Если сумма нечетная, тогда разделить ее ровно на 2 части невозможно, тогда
сразу возвращаем False.

Иначе ищем, можно ли набрать половину от общей суммы с помощью подмножества очков.
Для этого:
 - инициализируем массив 'dp' длинной 'target + 1', где dp[j] значит
 можно ли набрать сумму 'j' из подмножества очков.
 - заполняем, начиная с базового случая: dp[0] = True - сумма 0 всегда существует.
 - для каждого очка обновляем массив 'dp' в обратном порядке, чтобы избежать
 переиспользования одного и того же очка.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Алгоритм проходит по каждому очку и для каждого обновляет массив 'dp'длиной 'target',
поэтому временная сложность его будет O(n * target).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Здесь используется одномерный массив 'dp' длиной 'target + 1',
пространственную сложность O(n), где n == target (половина суммы всех очков).

Посылка: https://contest.yandex.ru/contest/25597/run-report/115021174/
"""


def can_partition(points: list) -> bool:
    total_sum: int = sum(points)
    if total_sum % 2 != 0:
        return False

    target: int = total_sum // 2
    dp: list[bool] = [False] * (target + 1)
    dp[0] = True

    for point in points:
        for j in range(target, point - 1, -1):
            dp[j] = dp[j] or dp[j - point]

    return dp[target]


n = int(input())
points = list(map(int, input().strip().split()))

print(can_partition(points))
